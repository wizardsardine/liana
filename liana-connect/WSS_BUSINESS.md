# WSS Protocol Specification for Liana Business

## Message Format

### Base Message Structure

All messages are JSON objects sent over WSS. Every message payload must include a
`token` field:

**Request Message Structure:**
```json
{
  "type": "<message_type>",
  "token": "<authentication_token>",
  "request_id": "<uuid>",
  "payload": { ... }
}
```

**Response Message Structure:**
```json
{
  "type": "<response_type>",
  "request_id": "<uuid>",  // Present only for responses to requests, absent for unsolicited notifications
  "payload": { ... },
  "error": { ... }  // Optional, present only on errors
}
```

### Placeholder Format

In all JSON examples, placeholders follow these rules:
- **String values** (including UUIDs, names, emails, tokens, etc.):
`"<placeholder>"` (with quotes)
- **Number values**: `<number>` (without quotes)
- **Boolean values**: `<boolean>` (without quotes)
- **Object references** (nested structures): `<ObjectName>` (without quotes, e.g.,
`<PolicyTemplate>`, `<User>`)

Examples:
- `"id": "<uuid>"` - UUID is a string, so it has quotes
- `"version": <version>` - Version is a number, so no quotes
- `"is_primary": <boolean>` - Boolean value, no quotes
- `"template": <PolicyTemplate>` - Object reference, no quotes

### Field Descriptions

- `type`: String identifying the message type (e.g., "connect", "ping", "fetch_org")
- `token`: String authentication token (obtained from existing auth client, required
  in all requests)
- `request_id`: String UUID generated by the client, must be unique for each request.
  Required in all request messages.
- `payload`: Object containing request/response-specific data
- `error`: Optional error object (present only when an error occurs)

## Connection Protocol

### Connection Handshake

1. Client establishes WSS connection to server URL
2. Client sends `connect` message with protocol version:
   ```json
   {
     "type": "connect",
     "token": "<auth_token>",
     "request_id": "<uuid>",
     "payload": {
       "version": <version>
     }
   }
   ```
3. Server responds with `connected` message:
   ```json
   {
     "type": "connected",
     "payload": {
       "version": <version>
     }
   }
   ```

### Connection Lifecycle

- **Connection**: Client initiates connection with `connect` message
- **Heartbeat**: Client sends `ping` messages periodically; server responds with
`pong`
- **Disconnection**: Either party can close the connection; client should call
`close()` method

### Version Negotiation

The protocol supports version negotiation:
- Client sends desired version in `connect` payload
- Server responds with accepted version in `connected` payload
- If versions are incompatible, server may close connection or return an error

## Message Types

### Connection Management

#### `connect`
Client initiates connection to server.

**Request:**
```json
{
  "type": "connect",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "version": <version>
  }
}
```

**Response:** [`connected`](#connected)

#### `connected`
Server confirms connection establishment.

**Response:**
```json
{
  "type": "connected",
  "request_id": "<uuid>",
  "payload": {
    "version": <version>
  }
}
```

**Note:** The `request_id` field is required when this is a response to a `connect` request,
matching the `request_id` from the original request.

**Maps to:** `Response::Connected { version: u8 }`

#### `ping`
Client heartbeat message.

**Request:**
```json
{
  "type": "ping",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {}
}
```

**Response:** [`pong`](#pong)

#### `pong`
Server heartbeat response.

**Response:**
```json
{
  "type": "pong",
  "request_id": "<uuid>",
  "payload": {}
}
```

**Note:** The `payload` field is optional and may be omitted or set to an empty object `{}`.

**Maps to:** `Response::Pong`

#### `close`
Client or server closes connection.

**Request:**
```json
{
  "type": "close",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {}
}
```

**Response:** Connection is closed, no response expected.

### Organization Management

#### `fetch_org`
Fetch organization by ID.

**Request:**
```json
{
  "type": "fetch_org",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "id": "<uuid>"
  }
}
```

**Response:** [`org`](#org-notification) (also see [Notifications](#notifications))

**Maps to:** `Response::Org { org: Org }`

### Wallet Management

#### `edit_wallet`
Update an existing wallet.

**Request:**
```json
{
  "type": "edit_wallet",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "wallet": {
      "id": "<uuid>",
      "alias": "<wallet_alias>",
      "org": "<uuid>",
      "owner": "<uuid>",
      "status": "<wallet_status>",
      "template": <PolicyTemplate>
    }
  }
}
```

**Note:** See [PolicyTemplate Object](#policytemplate-object) for nested structure
definition. The `owner` field contains only the UUID; the client should fetch and
cache the User object separately using `fetch_user`. The `template` field is optional
and may be omitted or `null`.

**Response:** [`wallet`](#wallet-notification) (also see
[Notifications](#notifications))

**Maps to:** `Response::Wallet { wallet: Wallet }`

#### `fetch_wallet`
Fetch wallet by ID.

**Request:**
```json
{
  "type": "fetch_wallet",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "id": "<uuid>"
  }
}
```

**Response:** [`wallet`](#wallet-notification) (also see
[Notifications](#notifications))

**Maps to:** `Response::Wallet { wallet: Wallet }`

#### `edit_xpub`
Update the xpub for a specific key in a wallet.

**Request:**
```json
{
  "type": "edit_xpub",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "wallet_id": "<uuid>",
    "key_id": <number>,
    "xpub": <Xpub> | null
  }
}
```

**Response:** [`wallet`](#wallet-notification) (also see
[Notifications](#notifications))

**Maps to:** `Response::Wallet { wallet: Wallet }`

**Note:** The `key_id` field specifies which key in the wallet's template to update
(corresponds to the key's `id` field in the `PolicyTemplate.keys` map). The `xpub`
field can be:
- An [Xpub Object](#xpub-object) when setting/updating the key
- `null` when clearing/removing the xpub

#### `device_registered`
Report that a device has registered the wallet descriptor.

**Request:**
```json
{
  "type": "device_registered",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "wallet_id": "<uuid>",
    "infos": <RegistrationInfos>
  }
}
```

**Response:** [`wallet`](#wallet-notification)

**Maps to:** `Response::Wallet { wallet: Wallet }`

**Note:** The `infos.registered` field should be `true`. The `infos.proof_of_registration`
field should contain the HMAC (hex-encoded) for Ledger devices, or `null` for other
devices. See [RegistrationInfos Object](#registrationinfos-object) for the structure.

**Note:** This request is only valid when the wallet is in `Registration(Pending)` status
and the user owns the device being registered (the `infos.user` must match the
authenticated user, and the `infos.fingerprint` must be assigned to that user in the
`registered_devices` map).

### User Management

#### `fetch_user`
Fetch user by ID.

**Request:**
```json
{
  "type": "fetch_user",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "id": "<uuid>"
  }
}
```

**Response:** [`user`](#user-notification) (also see [Notifications](#notifications))

**Maps to:** `Response::User { user: User }`

## Nested Data Structures

### User Object

NOTE: role can have WizardSardineAdmin | WalletManager | Participant values. Wallet ownership
must only be inferred from Wallet.owner.

```json
{
  "name": "<user_name>",
  "uuid": "<uuid>",
  "email": "<email>",
  "role": "<user_role>",
  "last_edited": <unix_timestamp> | null,
  "last_editor": "<uuid>" | null
}
```

**Note:** The `role` field can be one of the following values:
- `"WizardSardineAdmin"`: WizardSardine Admin role
- `"WalletManager"`: Wallet Manager role (customer)
- `"Participant"`: Participant role (customer)

**Note:** This structure is used only in `user` response messages. When a User is
referenced from other entities (e.g., `Wallet.owner`), only the UUID is included.
Clients should fetch and cache User objects separately.

### Org Object

```json
{
  "name": "<org_name>",
  "id": "<uuid>",
  "wallets": ["<uuid>"],
  "users": ["<uuid>"],
  "owners": ["<uuid>"],
  "last_edited": <unix_timestamp> | null,
  "last_editor": "<uuid>" | null
}
```

### Wallet Object

```json
{
  "id": "<uuid>",
  "alias": "<wallet_alias>",
  "org": "<uuid>",
  "owner": "<uuid>",
  "status": "<wallet_status>",
  "template": <PolicyTemplate> | null,
  "last_edited": <unix_timestamp> | null,
  "last_editor": "<uuid>" | null
}
```

**Note:** The `status` field can be one of the following values:
- `"Created"`: Empty wallet
- `"Drafted"`: Draft by WS manager
- `"Locked"`: Locked by WS manager, ready for owner validation
- `"Validated"`: Policy validated by owner, keys metadata not yet completed
- `{"Registration": {"Pending": {...}}}`: Descriptor generated, awaiting device registration
- `{"Registration": "Registered"}`: All devices have registered the descriptor
- `"Finalized"`: All key metadata filled, ready for production

**Note:** The `Registration` status has two sub-states:
- `Pending`: Contains the generated `descriptor` string and `registered_devices` map
- `Registered`: All devices have successfully registered the descriptor

**Note:** The `template` field is optional and may be `null` for newly created wallets.

### PolicyTemplate Object

```json
{
  "keys": {
    "<string>": <Key>
  },
  "primary_path": <SpendingPath>,
  "secondary_paths": [<SecondaryPath>]
}
```

**Note:** See [Key Object](#key-object), [SpendingPath Object](#spendingpath-object),
and [SecondaryPath Object](#secondarypath-object) for nested structure definitions.

### Key Object

```json
{
  "id": <number>,
  "alias": "<string>",
  "description": "<string>",
  "<identity_type>": "<identity_value>",
  "key_type": "<string>",
  "xpub": "<descriptor_public_key>" | null,
  "xpub_source": "<source>" | null,
  "xpub_device_kind": "<device_kind>" | null,
  "xpub_device_version": "<version>" | null,
  "xpub_file_name": "<filename>" | null,
  "last_edited": <unix_timestamp> | null,
  "last_editor": "<uuid>" | null
}
```

**Note:** The identity is represented as a flattened field with one of these keys:
- `"email"`: Key is linked to a user account (value is email address)
- `"token"`: Key is linked to a provider in the WS keys system (value is token)
- `"other"`: Key holder is not registered in any WS account systems (value is description)

**Note:** The `key_type` field can be one of: `"Internal"`, `"External"`, `"Cosigner"`, `"SafetyNet"`.

**Note:** The `xpub_source` field can be one of: `"Device"`, `"File"`, `"Pasted"`.

**Note:** The `xpub_device_kind` field (only when `xpub_source` is `"Device"`) can be one of:
`"Ledger"`, `"LedgerNano"`, `"LedgerNanoS"`, `"LedgerNanoPlus"`, `"LedgerFlex"`, `"LedgerStax"`,
`"SpecterDiy"`, `"Bitbox02"`, `"Bitbox02Nova"`, `"Jade"`, `"JadePlus"`, `"Coldcard"`,
`"ColdcardMk4"`, `"ColdcardQ"`, or any other string for unknown devices.

### Xpub Object

Used in `edit_xpub` request payloads:

```json
{
  "value": "<descriptor_public_key>",
  "source": "<source>",
  "device_kind": "<device_kind>" | null,
  "device_version": "<version>" | null,
  "file_name": "<filename>" | null
}
```

**Note:** The `source` field is required and can be one of: `"device"`, `"file"`, `"pasted"`.

**Note:** When `source` is `"device"`:
- `device_kind` should contain the hardware wallet type
- `device_version` optionally contains the firmware version

**Note:** When `source` is `"file"`:
- `file_name` optionally contains the original filename

### RegistrationInfos Object

Used in `device_registered` request payloads and in wallet registration status:

```json
{
  "user": "<uuid>",
  "fingerprint": "<fingerprint>",
  "registered": <boolean>,
  "registered_alias": "<string>" | null,
  "proof_of_registration": [<number>, ...] | null
}
```

**Note:** The `registered_alias` field contains the wallet name/alias used when registering
the descriptor on the hardware device. This is populated after successful device registration.

**Note:** The `proof_of_registration` field contains the HMAC as an array of bytes for Ledger
devices, or `null` for other device types. This field is only populated after successful
device registration.

**Note:** The `fingerprint` field is the hardware wallet master key fingerprint in
hex format (e.g., "d34db33f").

### SpendingPath Object

```json
{
  "is_primary": <boolean>,
  "threshold_n": <number>,
  "key_ids": [<number>],
  "last_edited": <unix_timestamp> | null,
  "last_editor": "<uuid>" | null
}
```

**Note:** `last_edited` is a Unix timestamp (seconds) indicating when the path was last
modified. `last_editor` is the UUID of the user who last edited this path. Both fields
are optional and omitted when not set.

### Timelock Object

```json
{
  "blocks": <number>
}
```

### SecondaryPath Object

```json
{
  "is_primary": <boolean>,
  "threshold_n": <number>,
  "key_ids": [<number>],
  "last_edited": <unix_timestamp> | null,
  "last_editor": "<uuid>" | null,
  "timelock": <Timelock>
}
```

**Note:** The SpendingPath fields are flattened into the SecondaryPath object.
See [SpendingPath Object](#spendingpath-object) and [Timelock
Object](#timelock-object) for field definitions.

## Notifications

The following message types can be received in two contexts:

1. **As responses to requests**: When a client sends a request (e.g., `fetch_org`,
`fetch_wallet`, `edit_wallet`), the server responds with the corresponding
notification type. In this case, the notification **MUST** include the `request_id`
field matching the `request_id` from the original request.

2. **As unsolicited notifications**: The server may send these messages at any time
to notify the client about changes made by other users or system events. For example:
   - Another user updates a wallet that the current user has access to
   - An organization is modified by another user
   - A user's information is updated by the system or another user
   In this case, the notification **MUST NOT** include the `request_id` field.

Clients should handle these messages identically regardless of whether they are
responses to requests or unsolicited notifications. The client should update its
cache and forward notifications to the UI. The presence or absence of `request_id`
indicates whether the notification is a response to a request or an unsolicited
notification.

### `org` Notification

**As response to request (with `request_id`):**
```json
{
  "type": "org",
  "request_id": "<uuid>",
  "payload": {
    "name": "<org_name>",
    "id": "<uuid>",
    "wallets": ["<uuid>"],
    "users": ["<uuid>"],
    "owners": ["<uuid>"],
    "last_edited": <unix_timestamp> | null,
    "last_editor": "<uuid>" | null
  }
}
```

**As unsolicited notification (without `request_id`):**
```json
{
  "type": "org",
  "payload": {
    "name": "<org_name>",
    "id": "<uuid>",
    "wallets": ["<uuid>"],
    "users": ["<uuid>"],
    "owners": ["<uuid>"],
    "last_edited": <unix_timestamp> | null,
    "last_editor": "<uuid>" | null
  }
}
```

**Note:** The `request_id` field is present when this notification is a response to
a request, and absent when it's an unsolicited notification (e.g., when another
user modifies the organization).

### `wallet` Notification

**As response to request (with `request_id`):**
```json
{
  "type": "wallet",
  "request_id": "<uuid>",
  "payload": {
    "id": "<uuid>",
    "alias": "<wallet_alias>",
    "org": "<uuid>",
    "owner": "<uuid>",
    "status": "<wallet_status>",
    "template": <PolicyTemplate> | null,
    "last_edited": <unix_timestamp> | null,
    "last_editor": "<uuid>" | null
  }
}
```

**As unsolicited notification (without `request_id`):**
```json
{
  "type": "wallet",
  "payload": {
    "id": "<uuid>",
    "alias": "<wallet_alias>",
    "org": "<uuid>",
    "owner": "<uuid>",
    "status": "<wallet_status>",
    "template": <PolicyTemplate> | null,
    "last_edited": <unix_timestamp> | null,
    "last_editor": "<uuid>" | null
  }
}
```

**Note:** See [PolicyTemplate Object](#policytemplate-object) for nested structure
definition. The `owner` field contains only the UUID; the client should fetch and
cache the User object separately using `fetch_user`.

**Note:** The `request_id` field is present when this notification is a response to
a request, and absent when it's an unsolicited notification (e.g., when another
user modifies the wallet).

**Note:** The `status` field can be one of the following values:
- `"Created"`: Empty wallet
- `"Drafted"`: Draft by WS manager
- `"Locked"`: Locked by WS manager, ready for owner validation
- `"Validated"`: Policy validated by owner, keys metadata not yet completed
- `{"Registration": {"Pending": {...}}}`: Descriptor generated, awaiting device registration
- `{"Registration": "Registered"}`: All devices have registered the descriptor
- `"Finalized"`: All key metadata filled, ready for production

### `user` Notification

**As response to request (with `request_id`):**
```json
{
  "type": "user",
  "request_id": "<uuid>",
  "payload": {
    "name": "<user_name>",
    "uuid": "<uuid>",
    "email": "<email>",
    "role": "<user_role>",
    "last_edited": <unix_timestamp> | null,
    "last_editor": "<uuid>" | null
  }
}
```

**As unsolicited notification (without `request_id`):**
```json
{
  "type": "user",
  "payload": {
    "name": "<user_name>",
    "uuid": "<uuid>",
    "email": "<email>",
    "role": "<user_role>",
    "last_edited": <unix_timestamp> | null,
    "last_editor": "<uuid>" | null
  }
}
```

**Note:** When a user is updated, the client should update its cache and refresh
all entities that reference this user (e.g., wallets with this user as owner) to
ensure consistency.

**Note:** The `request_id` field is present when this notification is a response to
a request, and absent when it's an unsolicited notification (e.g., when another
user or the system modifies the user data).

### `delete_user_org` Notification

This is an unsolicited notification sent when a user is removed from an organization.

**As unsolicited notification (always without `request_id`):**
```json
{
  "type": "delete_user_org",
  "payload": {
    "user": "<uuid>",
    "org": "<uuid>"
  }
}
```

**Note:** This notification is only sent as an unsolicited notification (never as
a response to a request). Clients should update their cache to remove the user
from the organization and refresh any views that display the organization's user list.

**Maps to:** `Response::DeleteUserOrg { user: Uuid, org: Uuid }`

## Error Handling

### Error Response Format

When an error occurs, the server responds with an error message:

```json
{
  "type": "error",
  "request_id": "<uuid>",
  "error": {
    "code": "<error_code>",
    "message": "<error_message>",
    "request_id": "<uuid>"
  }
}
```

**Note:** The `request_id` field at the protocol level is always present in error
responses, matching the `request_id` from the original request. When an error is
related to a specific request, the `request_id` field must also be included within
the error object itself, matching the protocol-level `request_id`. This allows
clients to correlate errors with their corresponding requests even when processing
the error object in isolation.

**Maps to:** `Response::Error { error: WssError }`

### Error Codes

- `INVALID_TOKEN`: Authentication token is invalid or expired
- `UNAUTHORIZED`: User does not have permission for the requested operation
- `NOT_FOUND`: Requested resource (org, wallet, user) not found
- `VALIDATION_ERROR`: Request payload validation failed
- `INTERNAL_ERROR`: Server internal error
- `PROTOCOL_ERROR`: Protocol version mismatch or invalid message format

## Example Message Flows

### Connection Flow

```
Client -> Server: {
  "type": "connect",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": { "version": <version> }
}

Server -> Client: {
  "type": "connected",
  "request_id": "<uuid>",
  "payload": { "version": <version> }
}
```

### Error Flow

```
Client -> Server: {
  "type": "fetch_org",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "id": "<uuid>"
  }
}

Server -> Client: {
  "type": "error",
  "request_id": "<uuid>",
  "error": {
    "code": "<error_code>",
    "message": "<error_message>",
    "request_id": "<uuid>"
  }
}
```

### Heartbeat Flow

```
Client -> Server: {
  "type": "ping",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {}
}

Server -> Client: {
  "type": "pong",
  "request_id": "<uuid>",
  "payload": {}
}
```

### Initial Connection with Data Fetching Flow

This flow demonstrates the complete sequence for establishing a connection and loading
initial data. Upon connection, the server sends unsolicited Org notifications for all
organizations the user belongs to. The client then fetches wallets and users.

**Actor:** Any authenticated user (WizardSardineAdmin, WalletManager, or Participant)

```
// Step 1: Establish connection
Client -> Server: Request::Connect { version: 1 }

Server -> Client: Response::Connected { version: 1 }

// Step 2: Server sends Org notifications for all user's organizations (unsolicited)
// Note: User can belong to multiple orgs - one notification per org
Server -> Client: Response::Org {
    org: Org {
        name: "Acme Corp",
        id: "org-uuid-001",
        wallets: ["wallet-uuid-001", "wallet-uuid-002"],
        users: ["user-uuid-001", "user-uuid-002"],
        owners: ["user-uuid-001"],
        ...
    }
}

Server -> Client: Response::Org {
    org: Org {
        name: "Side Project Inc",
        id: "org-uuid-002",
        wallets: ["wallet-uuid-010"],
        users: ["user-uuid-001", "user-uuid-010"],
        owners: ["user-uuid-010"],
        ...
    }
}

// Step 3: Fetch wallets from organizations (can be done in parallel)
Client -> Server: Request::FetchWallet { id: "wallet-uuid-001" }
Client -> Server: Request::FetchWallet { id: "wallet-uuid-002" }
Client -> Server: Request::FetchWallet { id: "wallet-uuid-010" }

Server -> Client: Response::Wallet {
    wallet: Wallet {
        id: "wallet-uuid-001",
        alias: "Treasury Vault",
        org: "org-uuid-001",
        owner: "user-uuid-001",
        status: WalletStatus::Validated,
        template: Some(PolicyTemplate {
            keys: {
                0: Key {
                    id: 0,
                    alias: "CEO Key",
                    description: "Primary signing key",
                    identity: KeyIdentity::Email("ceo@acme.com"),
                    key_type: KeyType::Internal,
                    xpub: None,
                    ...
                },
                1: Key {
                    id: 1,
                    alias: "CFO Key",
                    description: "Secondary signing key",
                    identity: KeyIdentity::Email("cfo@acme.com"),
                    key_type: KeyType::Internal,
                    xpub: None,
                    ...
                },
            },
            primary_path: SpendingPath {
                is_primary: true,
                threshold_n: 2,
                key_ids: [0, 1],
                ...
            },
            secondary_paths: [],
        }),
        ...
    }
}

// Step 4: Fetch users referenced in wallets and orgs
Client -> Server: Request::FetchUser { id: "user-uuid-001" }
Client -> Server: Request::FetchUser { id: "user-uuid-002" }
Client -> Server: Request::FetchUser { id: "user-uuid-010" }

Server -> Client: Response::User {
    user: User {
        name: "John Smith",
        uuid: "user-uuid-001",
        email: "ceo@acme.com",
        role: UserRole::Participant,
        ...
    }
}
```

### Key Management Flows

Key operations are performed by modifying the `template.keys` map in a wallet and
sending an `EditWallet` request. The entire wallet object must be sent with the
updated template.

#### Add Key Flow

**Actor:** WizardSardineAdmin or WalletManager

**Precondition:** Wallet exists with status "Drafted"

```
// Add a new key (id: 2) to an existing wallet with keys 0 and 1
Client -> Server: Request::EditWallet {
    wallet: Wallet {
        id: "wallet-uuid-001",
        alias: "Treasury Vault",
        org: "org-uuid-001",
        owner: "user-uuid-001",
        status: WalletStatus::Drafted,
        template: Some(PolicyTemplate {
            keys: {
                0: Key { id: 0, alias: "CEO Key", identity: KeyIdentity::Email("ceo@acme.com"), key_type: KeyType::Internal, ... },
                1: Key { id: 1, alias: "CFO Key", identity: KeyIdentity::Email("cfo@acme.com"), key_type: KeyType::Internal, ... },
                2: Key { id: 2, alias: "Recovery Key", identity: KeyIdentity::Other("External Law Firm"), key_type: KeyType::SafetyNet, ... },  // NEW
            },
            primary_path: SpendingPath { threshold_n: 2, key_ids: [0, 1], ... },
            secondary_paths: [],
        }),
        ...
    }
}

Server -> Client: Response::Wallet { wallet: Wallet { /* updated wallet with new key */ } }
```

#### Edit Key Flow

**Actor:** WizardSardineAdmin or WalletManager

**Precondition:** Wallet exists with the key to be modified and wallet must be
in "Drafted" status.

```
// Edit key 1: change alias, description, and identity
Client -> Server: Request::EditWallet {
    wallet: Wallet {
        id: "wallet-uuid-001",
        ...
        template: Some(PolicyTemplate {
            keys: {
                0: Key { id: 0, alias: "CEO Key", identity: KeyIdentity::Email("ceo@acme.com"), ... },
                1: Key { id: 1, alias: "Finance Director Key", identity: KeyIdentity::Email("finance@acme.com"), ... },  // MODIFIED
            },
            ...
        }),
        ...
    }
}

Server -> Client: Response::Wallet { wallet: Wallet { /* updated wallet with modified key */ } }
```

#### Remove Key Flow

**Actor:** WizardSardineAdmin or WalletManager

**Precondition:** Wallet exists with the key to be removed, key is not referenced in
any spending path and wallet must be in "Drafted" status.

```
// Remove key 2 from the wallet (key must not be in any path's key_ids)
Client -> Server: Request::EditWallet {
    wallet: Wallet {
        id: "wallet-uuid-001",
        ...
        template: Some(PolicyTemplate {
            keys: {
                0: Key { id: 0, ... },
                1: Key { id: 1, ... },
                // Key 2 is omitted - this removes it
            },
            ...
        }),
        ...
    }
}

Server -> Client: Response::Wallet { wallet: Wallet { /* updated wallet without key 2 */ } }
```

### Path Management Flows

Path operations are performed by modifying the `template.primary_path` or
`template.secondary_paths` in a wallet and sending an `EditWallet` request.

#### Add Path Flow

**Actor:** WizardSardineAdmin

**Precondition:** Wallet exists with keys that will be referenced in the new path and
wallet must be in "Drafted" status.

```
// Add a secondary (recovery) path with a 1-year timelock using key 2
Client -> Server: Request::EditWallet {
    wallet: Wallet {
        id: "wallet-uuid-001",
        status: WalletStatus::Drafted,
        template: Some(PolicyTemplate {
            keys: {
                0: Key { id: 0, alias: "CEO Key", ... },
                1: Key { id: 1, alias: "CFO Key", ... },
                2: Key { id: 2, alias: "Recovery Key", key_type: KeyType::SafetyNet, ... },
            },
            primary_path: SpendingPath { threshold_n: 2, key_ids: [0, 1], ... },
            secondary_paths: [
                SecondaryPath {
                    path: SpendingPath { threshold_n: 1, key_ids: [2], ... },
                    timelock: Timelock { blocks: 52560 },  // ~1 year
                },  // NEW
            ],
        }),
        ...
    }
}

Server -> Client: Response::Wallet { wallet: Wallet { /* updated wallet with new path */ } }
```

#### Edit Path Flow

**Actor:** WizardSardineAdmin 

**Precondition:** Wallet exists with the path to be modified wallet must be in
"Drafted" status.

```
// Edit the primary path: change from 2-of-2 to 2-of-3 by adding key 2
Client -> Server: Request::EditWallet {
    wallet: Wallet {
        id: "wallet-uuid-001",
        status: WalletStatus::Drafted,
        template: Some(PolicyTemplate {
            keys: {
                0: Key { id: 0, alias: "CEO Key", ... },
                1: Key { id: 1, alias: "CFO Key", ... },
                2: Key { id: 2, alias: "COO Key", ... },
            },
            primary_path: SpendingPath { threshold_n: 2, key_ids: [0, 1, 2], ... },  // MODIFIED: added key 2
            secondary_paths: [],
        }),
        ...
    }
}

Server -> Client: Response::Wallet { wallet: Wallet { /* updated wallet with modified path */ } }
```

#### Remove Path Flow

**Actor:** WizardSardineAdmin

**Precondition:** Wallet exists with secondary path(s) to be removed wallet must
be in "Drafted" status)

```
// Remove a secondary path by omitting it from the secondary_paths array
Client -> Server: Request::EditWallet {
    wallet: Wallet {
        id: "wallet-uuid-001",
        status: WalletStatus::Drafted,
        template: Some(PolicyTemplate {
            keys: { ... },
            primary_path: SpendingPath { threshold_n: 2, key_ids: [0, 1], ... },
            secondary_paths: [],  // Empty - secondary path removed
        }),
        ...
    }
}

Server -> Client: Response::Wallet { wallet: Wallet { /* updated wallet without secondary path */ } }
```

### Wallet Status Flows

Wallet status transitions are performed by changing the `status` field in a wallet
and sending an `EditWallet` request. The valid transitions are:
- `Created` → `Drafted` (WisardSardineAdmin creates initial template)
- `Drafted` → `Locked` (WisardSardineAdmin locks policy for owner validation)
- `Locked` → `Drafted` (WisardSardineAdmin unlocks to make changes)
- `Locked` → `Validated` (Wallet Manager validates the policy)
- `Validated` → `Finalized` (All keys have xpubs, this state chase must be done
either server side or from admin panel)

#### Lock Wallet Flow

**Actor:** WisardSardineAdmin

**Precondition:** Wallet is in "Drafted" status with complete policy template (at
least a recovery path)

```
// WisardSardineAdmin locks wallet for owner validation
Client -> Server: Request::EditWallet {
    wallet: Wallet {
        id: "wallet-uuid-001",
        status: WalletStatus::Locked,  // Changed from Drafted
        template: Some(PolicyTemplate { ... }),
        ...
    }
}

Server -> Client: Response::Wallet { wallet: Wallet { status: WalletStatus::Locked, ... } }
```

#### Unlock Wallet Flow

**Actor:** WisardSardineAdmin

**Precondition:** Wallet is in "Locked" status

```
// WisardSardineAdmin unlocks wallet to make changes
Client -> Server: Request::EditWallet {
    wallet: Wallet {
        id: "wallet-uuid-001",
        status: WalletStatus::Drafted,  // Changed from Locked
        template: Some(PolicyTemplate { ... }),
        ...
    }
}

Server -> Client: Response::Wallet { wallet: Wallet { status: WalletStatus::Drafted, ... } }
```

#### Validate Wallet Flow

**Actor:** Wallet Manager

**Precondition:** Wallet is in "Locked" status

```
// Wallet Manager validates the wallet policy
Client -> Server: Request::EditWallet {
    wallet: Wallet {
        id: "wallet-uuid-001",
        status: WalletStatus::Validated,  // Changed from Locked
        template: Some(PolicyTemplate { ... }),
        ...
    }
}

Server -> Client: Response::Wallet { wallet: Wallet { status: WalletStatus::Validated, ... } }
```

### Xpub Management Flows

Xpub operations use the dedicated `EditXpub` request. This allows updating
the extended public key for a specific key in a wallet without sending the entire
wallet object.

#### Add Xpub Flow

**Actor:** WisardSardineAdmin, Wallet Manager, or Participant (wallet must be in "Validated" status or
later)

**Precondition:** Wallet exists with the key to receive the xpub
and wallet must be in "Validated" status. 
If user has Participant role, user only allowed to edit key attached to his identity.


```
// Add xpub from a hardware device (Ledger Nano S)
Client -> Server: Request::EditXpub {
    wallet_id: "wallet-uuid-001",
    key_id: 0,
    xpub: Some(Xpub {
        value: "[d34db33f/48'/0'/0'/2']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/*",
        source: XpubSource::Device,
        device_kind: Some(DeviceKind::LedgerNanoS),
        device_version: Some("2.1.0"),
        file_name: None,
    }),
}

Server -> Client: Response::Wallet {
    wallet: Wallet {
        // Key 0 now has xpub set with device metadata
        ...
    }
}
```

#### Edit Xpub Flow

**Actor:** WisardSardineAdmin, Wallet Manager, or Participant

**Precondition:** Wallet exists with key that already has an xpub
and wallet must be in "Validated" status. 
If user has Participant role, user only allowed to edit key attached to his identity.

```
// Update xpub with a new device (upgrade from Nano S to Nano S Plus)
Client -> Server: Request::EditXpub {
    wallet_id: "wallet-uuid-001",
    key_id: 0,
    xpub: Some(Xpub {
        value: "[d34db33f/48'/0'/0'/2']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/*",
        source: XpubSource::Device,
        device_kind: Some(DeviceKind::LedgerNanoPlus),
        device_version: Some("1.0.4"),
        file_name: None,
    }),
}

Server -> Client: Response::Wallet { wallet: Wallet { /* key 0 xpub updated */ } }
```

#### Clear Xpub Flow

**Actor:** WisardSardineAdmin, Wallet Manager, or Participant

**Precondition:** Wallet exists with key that has an xpub to be cleared
and wallet must be in "Validated" status. 
If user has Participant role, user only allowed to edit key attached to his identity.

```
// Clear xpub by setting it to None
Client -> Server: Request::EditXpub {
    wallet_id: "wallet-uuid-001",
    key_id: 0,
    xpub: None,
}

Server -> Client: Response::Wallet { wallet: Wallet { /* key 0 xpub is now None */ } }
```

### Device Registration Flow

After the owner validates the wallet, the server transitions the wallet to
`Registration(Pending)` status with a generated descriptor. Each participant with
Internal keys must register the descriptor on their hardware devices.

**Actor:** Participant with Internal keys

**Precondition:** Wallet is in `Registration(Pending)` status, user has devices to register

```
// Step 1: Receive wallet with Registration status (after validation)
Server -> Client: Response::Wallet {
    wallet: Wallet {
        id: "wallet-uuid-001",
        status: WalletStatus::Registration(RegistrationStatus::Pending {
            descriptor: "wsh(or_d(multi(2,[d34db33f/48'/0'/0'/2']xpub.../0/*,...),and_v(...)))",
            registered_devices: {
                "d34db33f": RegistrationInfos {
                    user: "user-uuid-001",
                    fingerprint: "d34db33f",
                    registered: false,
                    registered_alias: None,
                    proof_of_registration: None,
                },
                "cafebabe": RegistrationInfos {
                    user: "user-uuid-002",
                    fingerprint: "cafebabe",
                    registered: false,
                    registered_alias: None,
                    proof_of_registration: None,
                },
            },
        }),
        ...
    }
}

// Step 2: User connects hardware device (fingerprint: d34db33f)
// Client detects device via HwiService, matches fingerprint to registered_devices

// Step 3: User initiates registration on device
// Client calls async-hwi register_wallet() which prompts user to confirm on device

// Step 4: After successful registration, client reports to server
Client -> Server: Request::DeviceRegistered {
    wallet_id: "wallet-uuid-001",
    infos: RegistrationInfos {
        user: "user-uuid-001",
        fingerprint: "d34db33f",
        registered: true,
        registered_alias: Some("My Wallet"),  // Alias used for registration
        proof_of_registration: Some("a1b2c3d4..."),  // HMAC for Ledger, None for others
    },
}

// Step 5: Server updates registration status and responds
Server -> Client: Response::Wallet {
    wallet: Wallet {
        id: "wallet-uuid-001",
        status: WalletStatus::Registration(RegistrationStatus::Pending {
            descriptor: "wsh(...)",
            registered_devices: {
                "d34db33f": RegistrationInfos {
                    user: "user-uuid-001",
                    fingerprint: "d34db33f",
                    registered: true,  // Now registered
                    registered_alias: Some("My Wallet"),
                    proof_of_registration: Some("a1b2c3d4..."),
                },
                "cafebabe": RegistrationInfos {
                    user: "user-uuid-002",
                    fingerprint: "cafebabe",
                    registered: false,  // Still waiting
                    registered_alias: None,
                    proof_of_registration: None,
                },
            },
        }),
        ...
    }
}

// Step 6: When ALL devices are registered, server transitions to Registered
// (After user-uuid-002 also registers their device)
Server -> Client: Response::Wallet {
    wallet: Wallet {
        id: "wallet-uuid-001",
        status: WalletStatus::Registration(RegistrationStatus::Registered),
        ...
    }
}
```

**Note:** The `proof_of_registration` field is only populated for Ledger devices (HMAC
hex string). For other device types (BitBox02, Coldcard, Jade, Specter), this field
should be `null`.

### Notification Flows (Unsolicited)

When another user modifies a wallet, organization, or user that you have access to,
the server sends an unsolicited notification. These notifications do NOT include
a `request_id`, distinguishing them from responses to your own requests.

#### Receiving Key Change Notification

**Scenario:** Another WisardSardineAdmin (user-uuid-002) edits a key in a wallet that you
(user-uuid-001) have access to.

```
// You receive this notification without having made a request
// Note: This is an unsolicited Response (no matching Request was sent)
Server -> Client: Response::Wallet {
    wallet: Wallet {
        id: "wallet-uuid-001",
        status: WalletStatus::Drafted,
        template: Some(PolicyTemplate {
            keys: {
                0: Key {
                    id: 0,
                    alias: "CEO Key - Updated",  // Changed by another user
                    last_edited: Some(1704240000),
                    last_editor: Some("user-uuid-002"),  // Shows who made the change
                    ...
                },
                1: Key { id: 1, ... },
            },
            ...
        }),
        last_edited: Some(1704240000),
        last_editor: Some("user-uuid-002"),
        ...
    }
}

// Client should:
// 1. Update local cache with the new wallet data
// 2. Notify UI to refresh the wallet view
// 3. Use last_editor field to show who made the change
```

#### Receiving Path Change Notification

**Scenario:** Another user adds a secondary recovery path to a shared wallet.

```
// Unsolicited notification - another user added a recovery path
Server -> Client: Response::Wallet {
    wallet: Wallet {
        id: "wallet-uuid-001",
        status: WalletStatus::Drafted,
        template: Some(PolicyTemplate {
            keys: {
                0: Key { ... },
                1: Key { ... },
                2: Key { id: 2, alias: "Recovery Key", key_type: KeyType::SafetyNet, ... },  // NEW
            },
            primary_path: SpendingPath { threshold_n: 2, key_ids: [0, 1], ... },
            secondary_paths: [
                SecondaryPath {
                    path: SpendingPath { threshold_n: 1, key_ids: [2], ... },
                    timelock: Timelock { blocks: 52560 },
                    last_edited: Some(1704240000),
                    last_editor: Some("user-uuid-002"),
                },  // NEW - added by another user
            ],
        }),
        last_edited: Some(1704240000),
        last_editor: Some("user-uuid-002"),
        ...
    }
}
```

### Cascading Entity Fetch Flow

This flow demonstrates how to handle receiving a notification for an entity that
references other entities not yet in the client's cache. The client must fetch
each referenced entity to build a complete view.

**Scenario:** Server adds you to a new organization. You receive an org notification
for an organization you've never seen before, containing references to wallets and
users that are not in your cache.

```
// Step 1: Receive unsolicited org notification (org not in cache)
Server -> Client: Response::Org {
    org: Org {
        name: "New Corp",
        id: "org-uuid-002",
        wallets: ["wallet-uuid-010", "wallet-uuid-011"],  // Not cached
        users: ["user-uuid-010", "user-uuid-011", "user-uuid-012"],  // Not cached
        owners: ["user-uuid-010"],
        ...
    }
}

// Client checks cache: org-uuid-002 is not cached
// Client caches the org, then fetches the wallets

// Step 2: Fetch the wallets (can be done in parallel)
Client -> Server: Request::FetchWallet { id: "wallet-uuid-010" }
Client -> Server: Request::FetchWallet { id: "wallet-uuid-011" }

Server -> Client: Response::Wallet {
    wallet: Wallet {
        id: "wallet-uuid-010",
        alias: "Operations Fund",
        org: "org-uuid-002",
        owner: "user-uuid-010",  // Not cached - need to fetch
        status: WalletStatus::Validated,
        template: Some(PolicyTemplate {
            keys: {
                0: Key { id: 0, alias: "Admin Key", identity: KeyIdentity::Email("admin@newcorp.com"), ... },
                1: Key { id: 1, alias: "Backup Key", identity: KeyIdentity::Email("backup@newcorp.com"), ... },
                2: Key { id: 2, alias: "External Cosigner", identity: KeyIdentity::Token("cosigner-token-001"), key_type: KeyType::Cosigner, ... },
            },
            primary_path: SpendingPath { threshold_n: 2, key_ids: [0, 1, 2], ... },
            secondary_paths: [],
        }),
        ...
    }
}

Server -> Client: Response::Wallet {
    wallet: Wallet {
        id: "wallet-uuid-011",
        alias: "Reserve Fund",
        org: "org-uuid-002",
        owner: "user-uuid-011",  // Not cached - need to fetch
        status: WalletStatus::Drafted,
        template: Some(PolicyTemplate {
            keys: {
                0: Key { id: 0, alias: "Treasury Key", identity: KeyIdentity::Email("treasury@newcorp.com"), ... },
            },
            primary_path: SpendingPath { threshold_n: 1, key_ids: [0], ... },
            secondary_paths: [],
        }),
        ...
    }
}

// Client caches both wallets
// Client checks: wallets reference users user-uuid-010 and user-uuid-011 (not cached)

// Step 3: Fetch the users referenced in wallets and org (can be done in parallel)
Client -> Server: Request::FetchUser { id: "user-uuid-010" }
Client -> Server: Request::FetchUser { id: "user-uuid-011" }
Client -> Server: Request::FetchUser { id: "user-uuid-012" }

Server -> Client: Response::User {
    user: User {
        name: "Alice Manager",
        uuid: "user-uuid-010",
        email: "admin@newcorp.com",
        role: UserRole::WalletManager,
        ...
    }
}

Server -> Client: Response::User {
    user: User {
        name: "Bob Backup",
        uuid: "user-uuid-011",
        email: "backup@newcorp.com",
        role: UserRole::WizardSardineAdmin,
        ...
    }
}

Server -> Client: Response::User {
    user: User {
        name: "Charlie Checker",
        uuid: "user-uuid-012",
        email: "checker@newcorp.com",
        role: UserRole::Participant,
        ...
    }
}

// Client caches all users
// Client now has complete data for:
// - 1 organization (org-uuid-002)
// - 2 wallets (wallet-uuid-010, wallet-uuid-011)
// - 3 users (user-uuid-010, user-uuid-011, user-uuid-012)
// UI can now display the complete organization view
```

## Implementation Notes

### Token Management

- The token is obtained from an existing authentication client (out of scope)
- The token must be included in all request messages
- The client should handle token expiration and refresh (handled by auth client)
- Invalid tokens will result in `INVALID_TOKEN` error responses

### Message Serialization

- All messages are JSON-encoded
- UUIDs are represented as strings in standard UUID format
- Timestamps and other numeric types follow JSON number format
- Enums (like `KeyType`) are represented as strings

### Message Correlation

The protocol uses `request_id` for request/response correlation:

- **Request correlation**: Every request message includes a `request_id` field
  (UUID generated by the client)
- **Response correlation**: Responses to requests include the same `request_id` from
  the original request
- **Notification correlation**:
  - Notifications that are responses to requests include the `request_id` from the
    original request
  - Unsolicited notifications do not include `request_id`
- **Error correlation**: Error responses always include the `request_id` from the
  original request at the protocol level. When an error is related to a specific
  request, the `request_id` must also be included within the error object itself,
  matching the protocol-level `request_id`

Clients should use `request_id` to match responses and notifications to their
corresponding requests. This is especially important when multiple requests are
sent concurrently, as responses may arrive out of order.

The `request_id` must be unique for each request generated by the client. Clients
should generate a new UUID for each request to ensure uniqueness.

### Concurrent Requests

Multiple requests can be sent concurrently over the same WebSocket connection. The
server processes them independently and may respond in any order. Clients MUST use
the `request_id` field to correlate responses with their corresponding requests,
rather than relying on message order.

### Data Caching and Reference Management

To minimize redundant data transfer and improve protocol efficiency, the protocol
uses UUID references instead of embedding complete objects:

- **UUID References**: When an entity references another entity (e.g.,
  `Wallet.owner`), only the UUID is included in the payload, not the full object.
- **Client Caching**: Clients are responsible for fetching and caching referenced
  entities separately:
  - When receiving a `Wallet` with an `owner` UUID, the client should check its
    cache for the `User` object
  - If not cached, the client should fetch it using `fetch_user`
  - The client should maintain a cache of fetched entities (orgs, wallets, users)
- **Cache Updates**: When an entity is updated, the server sends the updated entity
  as a notification. The client should:
  - Update its cache with the new entity data
  - Update all references to that entity throughout the application
  - This ensures consistency: when a user is updated, all wallets referencing that
    user reflect the update

## Protocol Version

Current protocol version: **1**

Future versions may add:
- Additional message types
- Enhanced error handling
- Batch operations
- Subscription/notification support

## Appendix: Request/Response Enum Reference

This section contains the Request and Response enum definitions as implemented in Rust.

### Request Enum

```rust
pub enum Request {
    Connect { version: u8 },
    Ping,
    Close,
    GetServerTime,
    FetchOrg { id: Uuid },
    EditWallet { wallet: Wallet },
    FetchWallet { id: Uuid },
    EditXpub {
        wallet_id: Uuid,
        key_id: u8,
        xpub: Option<Xpub>,
    },
    FetchUser { id: Uuid },
    DeviceRegistered {
        wallet_id: Uuid,
        infos: RegistrationInfos,
    },
}
```

### Response Enum

```rust
pub enum Response {
    Connected { version: u8 },
    Pong,
    ServerTime { timestamp: u64 },
    Org { org: Org },
    Wallet { wallet: Wallet },
    User { user: User },
    Error { error: WssError },
}
```

### Protocol Structures

```rust
/// Protocol-level request structure for serialization
pub struct ProtocolRequest {
    pub msg_type: String,      // "type" in JSON
    pub token: String,
    pub request_id: String,
    pub payload: Value,
}

/// Protocol-level response structure for deserialization
pub struct ProtocolResponse {
    pub msg_type: String,      // "type" in JSON
    pub request_id: Option<String>,
    pub payload: Option<Value>,
    pub error: Option<WssError>,
}

pub struct WssError {
    pub code: String,
    pub message: String,
    pub request_id: Option<String>,
}
```

**Note:** The `Request` enum provides a `to_ws_message(token, request_id)` method
that converts to the wire format. The `Response` enum provides a `from_ws_message()`
method that parses the wire format and returns both the response and the optional
`request_id`.
