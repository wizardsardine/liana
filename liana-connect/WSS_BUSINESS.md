# WSS Protocol Specification for Liana Business

## Message Format

### Base Message Structure

All messages are JSON objects sent over WSS. Every message payload must include a
`token` field:

**Request Message Structure:**
```json
{
  "type": "<message_type>",
  "token": "<authentication_token>",
  "request_id": "<uuid>",
  "payload": { ... }
}
```

**Response Message Structure:**
```json
{
  "type": "<response_type>",
  "request_id": "<uuid>",  // Present only for responses to requests, absent for unsolicited notifications
  "payload": { ... },
  "error": { ... }  // Optional, present only on errors
}
```

### Placeholder Format

In all JSON examples, placeholders follow these rules:
- **String values** (including UUIDs, names, emails, tokens, etc.):
`"<placeholder>"` (with quotes)
- **Number values**: `<number>` (without quotes)
- **Boolean values**: `<boolean>` (without quotes)
- **Object references** (nested structures): `<ObjectName>` (without quotes, e.g.,
`<PolicyTemplate>`, `<User>`)

Examples:
- `"id": "<uuid>"` - UUID is a string, so it has quotes
- `"version": <version>` - Version is a number, so no quotes
- `"is_primary": <boolean>` - Boolean value, no quotes
- `"template": <PolicyTemplate>` - Object reference, no quotes

### Field Descriptions

- `type`: String identifying the message type (e.g., "connect", "ping", "create_org")
- `token`: String authentication token (obtained from existing auth client, required
  in all requests)
- `request_id`: String UUID generated by the client, must be unique for each request.
  Required in all request messages.
- `payload`: Object containing request/response-specific data
- `error`: Optional error object (present only when an error occurs)

## Connection Protocol

### Connection Handshake

1. Client establishes WSS connection to server URL
2. Client sends `connect` message with protocol version:
   ```json
   {
     "type": "connect",
     "token": "<auth_token>",
     "request_id": "<uuid>",
     "payload": {
       "version": <version>
     }
   }
   ```
3. Server responds with `connected` message:
   ```json
   {
     "type": "connected",
     "payload": {
       "version": <version>
     }
   }
   ```

### Connection Lifecycle

- **Connection**: Client initiates connection with `connect` message
- **Heartbeat**: Client sends `ping` messages periodically; server responds with
`pong`
- **Disconnection**: Either party can close the connection; client should call
`close()` method

### Version Negotiation

The protocol supports version negotiation:
- Client sends desired version in `connect` payload
- Server responds with accepted version in `connected` payload
- If versions are incompatible, server may close connection or return an error

## Message Types

### Connection Management

#### `connect`
Client initiates connection to server.

**Request:**
```json
{
  "type": "connect",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "version": <version>
  }
}
```

**Response:** [`connected`](#connected)

#### `connected`
Server confirms connection establishment.

**Response:**
```json
{
  "type": "connected",
  "request_id": "<uuid>",
  "payload": {
    "version": <version>
  }
}
```

**Note:** The `request_id` field is required when this is a response to a `connect` request,
matching the `request_id` from the original request.

**Maps to:** `Response::Connected { version: u8 }`

#### `ping`
Client heartbeat message.

**Request:**
```json
{
  "type": "ping",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {}
}
```

**Response:** [`pong`](#pong)

#### `pong`
Server heartbeat response.

**Response:**
```json
{
  "type": "pong",
  "request_id": "<uuid>",
  "payload": {}
}
```

**Note:** The `payload` field is optional and may be omitted or set to an empty object `{}`.

**Maps to:** `Response::Pong`

#### `close`
Client or server closes connection.

**Request:**
```json
{
  "type": "close",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {}
}
```

**Response:** Connection is closed, no response expected.

### Organization Management

#### `fetch_org`
Fetch organization by ID.

**Request:**
```json
{
  "type": "fetch_org",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "id": "<uuid>"
  }
}
```

**Response:** [`org`](#org-notification) (also see [Notifications](#notifications))

**Maps to:** `Response::Org(Org)`

#### `remove_wallet_from_org`
Remove a wallet from an organization.

**Request:**
```json
{
  "type": "remove_wallet_from_org",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "wallet_id": "<uuid>",
    "org_id": "<uuid>"
  }
}
```

**Response:** [`org`](#org-notification) (also see [Notifications](#notifications))

**Maps to:** `Response::Org(Org)`

#### `create_wallet`
Create a new wallet.

**Request:**
```json
{
  "type": "create_wallet",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "name": "<wallet_name>",
    "org_id": "<uuid>",
    "owner_id": "<uuid>"
  }
}
```

**Response:** [`wallet`](#wallet-notification) (also see
[Notifications](#notifications))

**Maps to:** `Response::Wallet(Wallet)`

#### `edit_wallet`
Update an existing wallet.

**Request:**
```json
{
  "type": "edit_wallet",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "wallet": {
      "id": "<uuid>",
      "alias": "<wallet_alias>",
      "org": "<uuid>",
      "owner": "<uuid>",
      "status": "<wallet_status>",
      "template": <PolicyTemplate>
    }
  }
}
```

**Note:** See [PolicyTemplate Object](#policytemplate-object) for nested structure
definition. The `owner` field contains only the UUID; the client should fetch and
cache the User object separately using `fetch_user`.

**Response:** [`wallet`](#wallet-notification) (also see
[Notifications](#notifications))

**Maps to:** `Response::Wallet(Wallet)`

#### `fetch_wallet`
Fetch wallet by ID.

**Request:**
```json
{
  "type": "fetch_wallet",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "id": "<uuid>"
  }
}
```

**Response:** [`wallet`](#wallet-notification) (also see
[Notifications](#notifications))

**Maps to:** `Response::Wallet(Wallet)`

#### `edit_xpub`
Update the xpub for a specific key in a wallet.

**Request:**
```json
{
  "type": "edit_xpub",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "wallet_id": "<uuid>",
    "key_id": <number>,
    "xpub": "<string>" | null
  }
}
```

**Response:** [`wallet`](#wallet-notification) (also see
[Notifications](#notifications))

**Maps to:** `Response::Wallet(Wallet)`

**Note:** The `key_id` field specifies which key in the wallet's template to update
(corresponds to the key's `id` field in the `PolicyTemplate.keys` map). The `xpub`
field can be:
- A string containing the extended public key (DescriptorPublicKey) when
  setting/updating
- `null` when clearing/removing the xpub

#### `fetch_user`
Fetch user by ID.

**Request:**
```json
{
  "type": "fetch_user",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "id": "<uuid>"
  }
}
```

**Response:** [`user`](#user-notification) (also see [Notifications](#notifications))

**Maps to:** `Response::User(User)`

## Nested Data Structures

### User Object

```json
{
  "name": "<user_name>",
  "uuid": "<uuid>",
  "email": "<email>",
  "orgs": ["<uuid>"],
  "role": "<user_role>"
}
```

**Note:** The `role` field can be one of the following values:
- `"WSManager"`: Workspace Manager role
- `"Owner"`: Owner role
- `"Participant"`: Participant role

**Note:** This structure is used only in `user` response messages. When a User is
referenced from other entities (e.g., `Wallet.owner`), only the UUID is included.
Clients should fetch and cache User objects separately.

### PolicyTemplate Object

```json
{
  "keys": {
    "<string>": <Key>
  },
  "primary_path": <SpendingPath>,
  "secondary_paths": [<SecondaryPath>]
}
```

**Note:** See [Key Object](#key-object), [SpendingPath Object](#spendingpath-object),
and [SecondaryPath Object](#secondarypath-object) for nested structure definitions.

### Key Object

```json
{
  "id": <number>,
  "alias": "<string>",
  "description": "<string>",
  "email": "<email>",
  "key_type": "<string>",
  "xpub": "<string>" | null
}
```

**Note:** The `xpub` field is optional. It contains the extended public key 
(DescriptorPublicKey) as a string when set, or `null` when not yet configured.

### SpendingPath Object

```json
{
  "is_primary": <boolean>,
  "threshold_n": <number>,
  "key_ids": [<number>]
}
```

### Timelock Object

```json
{
  "blocks": <number>
}
```

### SecondaryPath Object

```json
{
  "path": <SpendingPath>,
  "timelock": <Timelock>
}
```

**Note:** See [SpendingPath Object](#spendingpath-object) and [Timelock
Object](#timelock-object) for nested structure definitions.

## Notifications

The following message types can be received in two contexts:

1. **As responses to requests**: When a client sends a request (e.g., `create_org`,
`fetch_wallet`, `edit_user`), the server responds with the corresponding
notification type. In this case, the notification **MUST** include the `request_id`
field matching the `request_id` from the original request.

2. **As unsolicited notifications**: The server may send these messages at any time
to notify the client about changes made by other users or system events. For example:
   - Another user updates a wallet that the current user has access to
   - An organization is modified by another user
   - A user's information is updated by the system or another user
   In this case, the notification **MUST NOT** include the `request_id` field.

Clients should handle these messages identically regardless of whether they are
responses to requests or unsolicited notifications. The client should update its
cache and forward notifications to the UI. The presence or absence of `request_id`
indicates whether the notification is a response to a request or an unsolicited
notification.

### `org` Notification

**As response to request (with `request_id`):**
```json
{
  "type": "org",
  "request_id": "<uuid>",
  "payload": {
    "name": "<org_name>",
    "id": "<uuid>",
    "wallets": ["<uuid>"],
    "users": ["<uuid>"],
    "owners": ["<uuid>"]
  }
}
```

**As unsolicited notification (without `request_id`):**
```json
{
  "type": "org",
  "payload": {
    "name": "<org_name>",
    "id": "<uuid>",
    "wallets": ["<uuid>"],
    "users": ["<uuid>"],
    "owners": ["<uuid>"]
  }
}
```

**Note:** The `request_id` field is present when this notification is a response to
a request, and absent when it's an unsolicited notification (e.g., when another
user modifies the organization).

### `wallet` Notification

**As response to request (with `request_id`):**
```json
{
  "type": "wallet",
  "request_id": "<uuid>",
  "payload": {
    "id": "<uuid>",
    "alias": "<wallet_alias>",
    "org": "<uuid>",
    "owner": "<uuid>",
    "status": "<wallet_status>",
    "template": <PolicyTemplate>
  }
}
```

**As unsolicited notification (without `request_id`):**
```json
{
  "type": "wallet",
  "payload": {
    "id": "<uuid>",
    "alias": "<wallet_alias>",
    "org": "<uuid>",
    "owner": "<uuid>",
    "status": "<wallet_status>",
    "template": <PolicyTemplate>
  }
}
```

**Note:** See [PolicyTemplate Object](#policytemplate-object) for nested structure
definition. The `owner` field contains only the UUID; the client should fetch and
cache the User object separately using `fetch_user`.

**Note:** The `request_id` field is present when this notification is a response to
a request, and absent when it's an unsolicited notification (e.g., when another
user modifies the wallet).

**Note:** The `status` field can be one of the following values:
- `"Created"`: Empty wallet
- `"Drafted"`: Draft by WS manager
- `"Validated"`: Policy validated by owner, keys metadata not yet completed
- `"Finalized"`: All key metadata filled, ready for production

### `user` Notification

**As response to request (with `request_id`):**
```json
{
  "type": "user",
  "request_id": "<uuid>",
  "payload": {
    "name": "<user_name>",
    "uuid": "<uuid>",
    "email": "<email>",
    "orgs": ["<uuid>"],
    "role": "<user_role>"
  }
}
```

**As unsolicited notification (without `request_id`):**
```json
{
  "type": "user",
  "payload": {
    "name": "<user_name>",
    "uuid": "<uuid>",
    "email": "<email>",
    "orgs": ["<uuid>"],
    "role": "<user_role>"
  }
}
```

**Note:** When a user is updated (via `edit_user`), the client should update its
cache and refresh all entities that reference this user (e.g., wallets with this
user as owner) to ensure consistency.

**Note:** The `request_id` field is present when this notification is a response to
a request, and absent when it's an unsolicited notification (e.g., when another
user or the system modifies the user data).

## Error Handling

### Error Response Format

When an error occurs, the server responds with an error message:

```json
{
  "type": "error",
  "request_id": "<uuid>",
  "error": {
    "code": "<error_code>",
    "message": "<error_message>",
    "request_id": "<uuid>"
  }
}
```

**Note:** The `request_id` field at the protocol level is always present in error
responses, matching the `request_id` from the original request. When an error is
related to a specific request, the `request_id` field must also be included within
the error object itself, matching the protocol-level `request_id`. This allows
clients to correlate errors with their corresponding requests even when processing
the error object in isolation.

### Error Codes

- `INVALID_TOKEN`: Authentication token is invalid or expired
- `UNAUTHORIZED`: User does not have permission for the requested operation
- `NOT_FOUND`: Requested resource (org, wallet, user) not found
- `VALIDATION_ERROR`: Request payload validation failed
- `INTERNAL_ERROR`: Server internal error
- `PROTOCOL_ERROR`: Protocol version mismatch or invalid message format

### Error Mapping

The client should map server errors to `Response::Error(Error)` variants. The
`Error` enum currently supports:
- `Error::None`: No error
- `Error::SubscriptionFailed`: Iced subscription failed

Additional error variants may need to be added to handle WSS-specific errors.

## Example Message Flows

### Connection Flow

```
Client -> Server: {
  "type": "connect",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": { "version": <version> }
}

Server -> Client: {
  "type": "connected",
  "request_id": "<uuid>",
  "payload": { "version": <version> }
}
```

### Error Flow

```
Client -> Server: {
  "type": "fetch_org",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {
    "id": "<uuid>"
  }
}

Server -> Client: {
  "type": "error",
  "request_id": "<uuid>",
  "error": {
    "code": "<error_code>",
    "message": "<error_message>",
    "request_id": "<uuid>"
  }
}
```

### Heartbeat Flow

```
Client -> Server: {
  "type": "ping",
  "token": "<auth_token>",
  "request_id": "<uuid>",
  "payload": {}
}

Server -> Client: {
  "type": "pong",
  "request_id": "<uuid>",
  "payload": {}
}
```

## Implementation Notes

### Token Management

- The token is obtained from an existing authentication client (out of scope)
- The token must be included in all request messages
- The client should handle token expiration and refresh (handled by auth client)
- Invalid tokens will result in `INVALID_TOKEN` error responses

### Message Serialization

- All messages are JSON-encoded
- UUIDs are represented as strings in standard UUID format
- Timestamps and other numeric types follow JSON number format
- Enums (like `KeyType`) are represented as strings

### Message Correlation

The protocol uses `request_id` for request/response correlation:

- **Request correlation**: Every request message includes a `request_id` field
  (UUID generated by the client)
- **Response correlation**: Responses to requests include the same `request_id` from
  the original request
- **Notification correlation**: 
  - Notifications that are responses to requests include the `request_id` from the
    original request
  - Unsolicited notifications do not include `request_id`
- **Error correlation**: Error responses always include the `request_id` from the
  original request at the protocol level. When an error is related to a specific
  request, the `request_id` must also be included within the error object itself,
  matching the protocol-level `request_id`

Clients should use `request_id` to match responses and notifications to their
corresponding requests. This is especially important when multiple requests are
sent concurrently, as responses may arrive out of order.

The `request_id` must be unique for each request generated by the client. Clients
should generate a new UUID for each request to ensure uniqueness.

### Concurrent Requests

Multiple requests can be sent concurrently over the same WebSocket connection. The
server processes them independently and may respond in any order. Clients should use
the `request_id` field to correlate responses with their corresponding requests,
rather than relying on message order.

### Data Caching and Reference Management

To minimize redundant data transfer and improve protocol efficiency, the protocol
uses UUID references instead of embedding complete objects:

- **UUID References**: When an entity references another entity (e.g.,
  `Wallet.owner`), only the UUID is included in the payload, not the full object.
- **Client Caching**: Clients are responsible for fetching and caching referenced
  entities separately:
  - When receiving a `Wallet` with an `owner` UUID, the client should check its
    cache for the `User` object
  - If not cached, the client should fetch it using `fetch_user`
  - The client should maintain a cache of fetched entities (orgs, wallets, users)
- **Cache Updates**: When an entity is updated (e.g., `edit_user`), the server sends
  a `user` response. The client should:
  - Update its cache with the new entity data
  - Update all references to that entity throughout the application
  - This ensures consistency: when a user is updated, all wallets referencing that
    user reflect the update
- **Cache-Only Methods**: The `get_orgs()`, `get_org()`, `get_user()`, and
  `get_wallet()` methods in the Backend trait are cache-only and do not make WSS
  requests; they return data from the client's local cache.

## Protocol Version

Current protocol version: **1**

Future versions may add:
- Additional message types
- Enhanced error handling
- Message correlation IDs
- Batch operations
- Subscription/notification support

## Appendix: Backend Trait Reference

This section contains the complete Backend trait definition with method signatures
and comments as defined in the Rust implementation.

```rust
pub trait Backend {
    // Auth, not part of WSS protocol
    fn auth_request(&mut self, email: String);  // -> Response::AuthCodeSent
                                                // -> Response::InvalidEmail
                                                // -> Response::AuthCodeFail
    fn auth_code(&mut self, code: String);  // -> Response::LoginSuccess
                                            // -> Response::LoginFail

    // Cache only, not backend calls
    fn get_orgs(&self) -> BTreeMap<Uuid, Org>;
    fn get_org(&self, id: Uuid) -> Option<OrgData>;
    fn get_user(&self, id: Uuid) -> Option<User>;
    fn get_wallet(&self, id: Uuid) -> Option<Wallet>;

    // Connection (WSS)
    fn connect(&mut self, url: String, version: u8) -> mpsc::Receiver<Response>; // -> Response::Connected
    fn ping(&mut self); // -> Response::Pong
    fn close(&mut self);    // Connection closed

    // Org management (WSS)
    fn fetch_org(&mut self, id: Uuid);                                      // -> Response::Org
    fn remove_wallet_from_org(&mut self, wallet_id: Uuid, org_id: Uuid);    // -> Response::Org

    fn create_wallet(&mut self, name: String, org: Uuid, owner: Uuid);      // -> Response::Wallet
    fn edit_wallet(&mut self, wallet: Wallet);                              // -> Response::Wallet
    fn fetch_wallet(&mut self, id: Uuid);                                   // -> Response::Wallet
    fn edit_xpub(
        &mut self,
        wallet_id: Uuid,
        xpub: Option<DescriptorPublicKey>,
        key_id: u8);                                                     // -> Response::Wallet

    fn fetch_user(&mut self, id: Uuid);         // -> Response::User
}
```

**Note:** Methods marked with "not part of WSS protocol" (auth methods) are handled
by an existing authentication client and are out of scope for this protocol
specification. Methods marked as "Cache only" do not make WSS requests and return
data from the client's local cache.

